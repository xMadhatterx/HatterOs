#include "font.h"
#include "util.h"

// Fallback "unknown character" box glyph.
static const UINT8 fallback_glyph[8] = {0x7E,0x42,0x5A,0x5A,0x5A,0x42,0x7E,0x00};
static const UINT8 glyph_space[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
static const UINT8 glyph_bang[8] = {0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x00};
static const UINT8 glyph_dot[8] = {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00};
static const UINT8 glyph_colon[8] = {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00};
static const UINT8 glyph_dash[8] = {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00};
static const UINT8 glyph_underscore[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00};
static const UINT8 glyph_slash[8] = {0x06,0x0C,0x18,0x30,0x60,0x40,0x00,0x00};
static const UINT8 glyph_backslash[8] = {0x60,0x30,0x18,0x0C,0x06,0x02,0x00,0x00};
static const UINT8 glyph_gt[8] = {0x40,0x60,0x30,0x18,0x30,0x60,0x40,0x00};
static const UINT8 glyph_lt[8] = {0x02,0x06,0x0C,0x18,0x0C,0x06,0x02,0x00};
static const UINT8 glyph_qmark[8] = {0x3C,0x42,0x02,0x0C,0x18,0x00,0x18,0x00};

static const UINT8 glyph_digit[10][8] = {
    {0x3C,0x66,0x6E,0x76,0x66,0x66,0x3C,0x00},
    {0x18,0x38,0x18,0x18,0x18,0x18,0x3C,0x00},
    {0x3C,0x66,0x06,0x1C,0x30,0x66,0x7E,0x00},
    {0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00},
    {0x0C,0x1C,0x3C,0x6C,0x7E,0x0C,0x0C,0x00},
    {0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00},
    {0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00},
    {0x7E,0x66,0x06,0x0C,0x18,0x18,0x18,0x00},
    {0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00},
    {0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00}
};

static const UINT8 glyph_alpha[26][8] = {
    {0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00},
    {0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00},
    {0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00},
    {0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00},
    {0x7E,0x60,0x60,0x7C,0x60,0x60,0x7E,0x00},
    {0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x00},
    {0x3C,0x66,0x60,0x6E,0x66,0x66,0x3E,0x00},
    {0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00},
    {0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00},
    {0x1E,0x0C,0x0C,0x0C,0x0C,0x6C,0x38,0x00},
    {0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00},
    {0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00},
    {0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x00},
    {0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x00},
    {0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00},
    {0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00},
    {0x3C,0x66,0x66,0x66,0x66,0x6C,0x36,0x00},
    {0x7C,0x66,0x66,0x7C,0x78,0x6C,0x66,0x00},
    {0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00},
    {0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00},
    {0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00},
    {0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00},
    {0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00},
    {0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00},
    {0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00},
    {0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00}
};

// Map ASCII character to an 8x8 bitmap.
static const UINT8 *lookup_glyph(char ch) {
    if (ch >= 'a' && ch <= 'z') {
        ch = (char)(ch - 'a' + 'A');
    }

    if (ch >= '0' && ch <= '9') {
        return glyph_digit[ch - '0'];
    }

    if (ch >= 'A' && ch <= 'Z') {
        return glyph_alpha[ch - 'A'];
    }

    switch (ch) {
    case ' ': return glyph_space;
    case '!': return glyph_bang;
    case '.': return glyph_dot;
    case ':': return glyph_colon;
    case '-': return glyph_dash;
    case '_': return glyph_underscore;
    case '/': return glyph_slash;
    case '\\': return glyph_backslash;
    case '>': return glyph_gt;
    case '<': return glyph_lt;
    case '?': return glyph_qmark;
    default: return fallback_glyph;
    }
}

// Draw one character at (x, y).
// Each source row is duplicated vertically so the effective cell is 8x16.
void font_draw_char(GfxContext *ctx, UINTN x, UINTN y, char ch, UINT32 fg, UINT32 bg, UINTN scale, BOOLEAN transparent_bg) {
    if (scale == 0) {
        scale = 1;
    }

    const UINT8 *glyph = lookup_glyph(ch);

    for (UINTN gy = 0; gy < 8; gy++) {
        UINT8 row = glyph[gy];
        for (UINTN gx = 0; gx < 8; gx++) {
            BOOLEAN set = (row & (1U << (7 - gx))) != 0;
            UINT32 color = set ? fg : bg;
            if (!set && transparent_bg) {
                continue;
            }

            UINTN draw_y = y + (gy * 2 * scale);
            UINTN draw_x = x + (gx * scale);

            // Render each source row twice so an 8x8 glyph becomes 8x16.
            gfx_fill_rect(ctx, draw_x, draw_y, scale, scale, color);
            gfx_fill_rect(ctx, draw_x, draw_y + scale, scale, scale, color);
        }
    }
}

// Draw a null-terminated text string using fixed-width cells.
void font_draw_text(GfxContext *ctx, UINTN x, UINTN y, const char *text, UINT32 fg, UINT32 bg, UINTN scale, BOOLEAN transparent_bg) {
    UINTN cursor_x = x;
    while (*text) {
        font_draw_char(ctx, cursor_x, y, *text, fg, bg, scale, transparent_bg);
        cursor_x += FONT_CHAR_WIDTH * scale;
        text++;
    }
}

// Return pixel width for a given string/scale pair.
UINTN font_text_width(const char *text, UINTN scale) {
    return u_strlen(text) * FONT_CHAR_WIDTH * ((scale == 0) ? 1 : scale);
}
